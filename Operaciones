import java.util.*;

public class Grafos {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Selecciona tipo de representación:\n1. Lista\n2. Matriz\n3. Aristas");
        int tipo = sc.nextInt();

        int n = 4;
        Object grafo = crearGrafo(tipo, n);
        System.out.println("\nGrafo inicial:");
        mostrarGrafo(grafo, tipo, n);

        eliminarArista(grafo, tipo, 1, 2);
        System.out.println("\nTras eliminar arista (1,2):");
        mostrarGrafo(grafo, tipo, n);

        eliminarVertice(grafo, tipo, 2, n);
        System.out.println("\nTras eliminar vértice 2:");
        mostrarGrafo(grafo, tipo, n);

        adyacentesYGrado(grafo, tipo, 0, 1, n);
    }

    static Object crearGrafo(int tipo, int n) {
        return switch (tipo) {
            case 1 -> {
                Map<Integer, List<Integer>> g = new HashMap<>();
                for (int i = 0; i < n; i++) g.put(i, new ArrayList<>());
                g.get(0).add(1); g.get(1).add(2); g.get(2).add(3);
                yield g;
            }
            case 2 -> {
                int[][] m = new int[n][n];
                m[0][1] = 1; m[1][2] = 1; m[2][3] = 1;
                yield m;
            }
            case 3 -> new ArrayList<>(List.of(
                new int[]{0, 1}, new int[]{1, 2}, new int[]{2, 3}
            ));
            default -> throw new IllegalArgumentException("Tipo inválido");
        };
    }

    static void mostrarGrafo(Object g, int tipo, int n) {
        switch (tipo) {
            case 1 -> ((Map<Integer, List<Integer>>) g).forEach((k, v) -> System.out.println(k + " -> " + v));
            case 2 -> Arrays.stream((int[][]) g).map(Arrays::toString).forEach(System.out::println);
            case 3 -> ((List<int[]>) g).forEach(a -> System.out.println(Arrays.toString(a)));
        }
    }

    static void eliminarArista(Object g, int tipo, int u, int v) {
        switch (tipo) {
            case 1 -> ((Map<Integer, List<Integer>>) g).get(u).remove(Integer.valueOf(v));
            case 2 -> ((int[][]) g)[u][v] = 0;
            case 3 -> ((List<int[]>) g).removeIf(a -> a[0] == u && a[1] == v);
        }
    }

    static void eliminarVertice(Object g, int tipo, int v, int n) {
        switch (tipo) {
            case 1 -> {
                Map<Integer, List<Integer>> mapa = (Map<Integer, List<Integer>>) g;
                mapa.remove(v);
                mapa.values().forEach(l -> l.remove(Integer.valueOf(v)));
            }
            case 2 -> {
                int[][] m = (int[][]) g;
                for (int i = 0; i < n; i++) {
                    m[v][i] = 0;
                    m[i][v] = 0;
                }
            }
            case 3 -> ((List<int[]>) g).removeIf(a -> a[0] == v || a[1] == v);
        }
    }

    static void adyacentesYGrado(Object g, int tipo, int nodoA, int nodoB, int n) {
        System.out.print("\nAdyacentes de " + nodoA + ": ");
        switch (tipo) {
            case 1 -> System.out.println(((Map<Integer, List<Integer>>) g).get(nodoA));
            case 2 -> {
                int[][] m = (int[][]) g;
                for (int j = 0; j < n; j++) if (m[nodoA][j] == 1) System.out.print(j + " ");
                System.out.println();
            }
            case 3 -> {
                for (int[] a : (List<int[]>) g)
                    if (a[0] == nodoA) System.out.print(a[1] + " ");
                System.out.println();
            }
        }

        long grado = switch (tipo) {
            case 1 -> ((Map<Integer, List<Integer>>) g).get(nodoB).size();
            case 2 -> Arrays.stream(((int[][]) g)[nodoB]).sum();
            case 3 -> ((List<int[]>) g).stream().filter(a -> a[0] == nodoB).count();
            default -> 0;
        };
        System.out.println("Grado de " + nodoB + ": " + grado);
    }
}
